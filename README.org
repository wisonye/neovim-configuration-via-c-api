* My Neovim configuration rewrite in system programming language

** Why do this? What's the purposes?

This is the statistics result of my =/backup/nvim_lua= folder:

#+BEGIN_SRC bash
   I  wison | /backup/nvim_lua   tokei --sort lines --type lua ./
  ===============================================================================
   Language            Files        Lines         Code     Comments       Blanks
  ===============================================================================
   Lua                    43         6332         3384         2233          715
  ===============================================================================
   Total                  43         6332         3384         2233          715
  ===============================================================================
#+END_SRC

As you can see that, I hand-wrote =3384= lines of =Lua= to configure my Neovim to what I want (of course, some of the custom plugins serve the same purpose with different implementations; that's my habit: build the same thing in a different way to iterate on the best solution).

The custom plugin I wrote includes the following:

- =Dired=: An Emacs major mode for directory browsing and editing, rewritten in Lua to use in Neovim.

        Example =dired buffer=:

    #+BEGIN_SRC bash
        # [ Dired buffer ]
        /Users/wison/rust:
        total 16
        drwxr-xr-x   23 wison  staff   736B 14 Dec 16:20 temp-rust
        drwxr-xr-x   12 wison  staff   384B 14 Dec 16:12 my-neovim-config
        drwxr-x---+ 101 wison  staff   3.2K 14 Dec 09:56 ..
        drwxr-xr-x   12 wison  staff   384B 30 Nov 10:21 .
        drwxr-xr-x   20 wison  staff   640B 30 Nov 10:18 nvim-oxi
        drwxr-xr-x    8 wison  staff   256B 27 Nov 13:48 rust-ffi-demo
        drwxr-xr-x    9 wison  staff   288B 27 Nov 11:42 rust-utils
        drwxr-xr-x    9 wison  staff   288B 25 Nov 08:30 universal-package-manager
        drwxr-xr-x    8 wison  staff   256B 23 Nov 10:00 ratatui-demo
        drwxr-xr-x   46 wison  staff   1.4K 23 Nov 09:46 ratatui
    #+END_SRC


- =ProjectCommand=: A module to show a command list picker based on the current project scope. You can add or select a pre-filled command and run it to compile your project and run the binary; the result appears in a right-split terminal buffer window. If compilation fails, pressing ENTER on the error line will bring you to the source code.

        Example Project command picker:

        #+BEGIN_SRC bash
           ╭──────────────────────────────────────────────╮
           │  Project Command ('Ctrl+e' to close picker)  │
           │──────────────────────────────────────────────│
           │                                              │
           │──────────────────────────────────────────────│
           │  ./configure.sh                              │
           │  ./run-call-odin-from-c.sh                   │
           │  ./run-emacs-lib.sh                          │
           │  ./run-multi-threading.sh                    │
           │  ./run-raylib-test.sh                        │
           │  ./run-tcp-client.sh                         │
           │  ./run-tcp-server.sh                         │
           │  ./run-test.sh                               │
           │  ./run.sh                                    │
           ╰──────────────────────────────────────────────╯
        #+END_SRC


        Example Project command buffer output:

        #+BEGIN_SRC bash
        Command: ./run-test.sh
        -------------------------------------------------------

        # [ Usage ]
        # dynamically linked Debug build  : ./run-test.sh
        # dynamically linked Relase build : RELEASE_BUILD=true ./run-test.sh
        #

        >>> [ RUN ]
        >>> OS_TYPE: Darwin
        >>> BUILD_TYPE: Debug
        >>> COMMAND: odin build src/main_test.odin
        -file  -debug
        -out:./temp_build/main_test
        -collection:utils=/Users/wison/odin/odin-utils
        -define:LOGGER_LEVEL=0
        -define:LOGGER_BUFFER_SIZE=512
        -define:ENABLE_DEBUG_LOG=true
        -define:DEFAULT_TEMP_ALLOCATOR_BACKING_SIZE=256
        -define:TERMINAL_ENABLE_DEBUG_LOG=true
        -define:ENABLE_FRAME_DEBUG_PRINT=true
        -define:ENABLE_FRAME_DECODE_DEBUG_LOG=true
        -define:ENABLE_FRAME_DECODE_ERROR_LOG=true
        -define:ENABLE_FRAME_ENCODE_DEBUG_LOG=true
        -define:UTILS_RING_BUFFER_QUEUE_CAPACITY=20
        -define:EVENT_LOOP_ENABLE_DEBUG_LOG=true
        && ./temp_build/main_test
        >>>> COMMAND_IN_ONE_LINE: odin build src/main_test.odin  -file  -debug  -out:./temp_build/main_test  -collection:utils=/Users/wison/odin/odin-utils  -define:LOGGER_LEVEL=0  -define:LOGGER_BUFFER_SIZE=512  -define:ENABLE_DEBUG_LOG=true  -define:DEFAULT_TEMP_ALLOCATOR_BACKING_SIZE=256  -define:TERMINAL_ENABLE_DEBUG_LOG=true  -define:ENABLE_FRAME_DEBUG_PRINT=true  -define:ENABLE_FRAME_DECODE_DEBUG_LOG=true  -define:ENABLE_FRAME_DECODE_ERROR_LOG=true  -define:ENABLE_FRAME_ENCODE_DEBUG_LOG=true  -define:UTILS_RING_BUFFER_QUEUE_CAPACITY=20  -define:EVENT_LOOP_ENABLE_DEBUG_LOG=true  && ./temp_build/main_test 

        >>> arr ==  nil: true
        >>> len(arr): 0
        #+END_SRC


That said, I wrote a lot of Lua code just for an editor configuration:) That's fine for me, as I learned a lot from this process. 

On the other hand, I also use =Emacs=, which is even more usecase than =Neovim=. That said, I hand-wrote a lot of =Emacs-Lisp= as well, here is the statistics result of my =/backup/emacs= folder:


#+BEGIN_SRC bash
   N  wison | /backup/emacs   tokei --sort lines --type "Emacs Lisp",Org
  ===============================================================================
   Language            Files        Lines         Code     Comments       Blanks
  ===============================================================================
   Org                     3        12891        10000           86         2805
   Emacs Lisp              6         7232         4058         2304          870
  ===============================================================================
   Total                   9        20123        14058         2390         3675
  ===============================================================================
#+END_SRC

Both =Lua= and =Emacs Lisp= are NOT my perferred language IF I have a choice. I prefer to use my favourite system programming language to write all my configurations:

=Odin, Hare, Zig, Rust, C=

That's what this little project tries to do, and see how it goes:)


** How it works?

Neovim has a detailed C API that you call via FFI:

- Source code: https://github.com/neovim/neovim/blob/release-0.11/src/nvim/api/

- Docs: https://neovim.io/doc/user/api.html

- Lua call FFI via dynamic-linked library: https://neovim.discourse.group/t/calling-neovim-internal-functions-with-luajit-ffi-and-rust/165


So, basically, you have a few choices to write your configuration in your favourite system programming languages, depends on what you want.

My first try is [[https://github.com/noib3/nvim-oxi][nvim-oxi]]: A neovim API rust bindings. After this, I will try to do the =Odin= version.


** Rust version

*** Project folder structure

#+BEGIN_SRC bash
  tree -L2
  .
  ├── build_release.sh     # Compile and copy to Neovim config directory (release build)
  ├── build.sh             # Compile and copy to Neovim config directory (debug build)
  ├── Cargo.lock
  ├── Cargo.toml
  ├── README.org
  └── src
      ├── lib.rs           # Pluging entry point
      ├── settings.rs
      ├── keybindings.rs
      ├── auto_groups.rs
      ├── my_dired.rs
      └── utils.rs
#+END_SRC


*** How to build and test

Run =build.sh= (debug build) or =build_release.sh= (release build) script: it compiles this plugin and copy the dynamic-linked library to =~/.config/nvim/lua=.

Both =build.sh= and =build_release.sh= are written in =fish shell= script. If you're using another shell, then you can compile and do a copy manually like this:

#+BEGIN_SRC fish
  #
  # Release build
  #
  cargo build --release

  #
  # MacOS: Rename to neomv configuration lua folder
  #
  mv target/release/libmy_neovim_configuration.dylib ~/.config/nvim/lua/my_neovim_configuration.so

  #
  # Linux/BSD: Rename to neomv configuration lua folder
  #
  mv target/release/libmy_neovim_configuration.so ~/.config/nvim/lua/my_neovim_configuration.so
#+END_SRC


Finally, create =~/.config/nvim/my-init.lua= (or modify your own =init.lua=) with the following setttings to load the plugin:

#+BEGIN_SRC lua-ts
  require("my_neovim_configuration")
#+END_SRC


*** Detail explanation

**** Plugin entry point

#+BEGIN_SRC rust
  #[nvim_oxi::plugin]
  fn my_neovim_configuration() -> bool {

      // This is your Neovim plugin entry point:)

      true
  }

  #[cfg(feature = "enable_plugin_debug_print")]
  use nvim_oxi as nvim;
#+END_SRC


~#[nvim_oxi::plugin]~ marks this function as the entrypoint of the plugin.

The entry point function will be called by Neovim when the user loads the plugin by passing its name to the ~require~ function. It can return any type that implements the ~Pushable~ trait, and the value will be returned on the ~Lua~ side by require.

The ~Pushable~ trait located in ~nvim-oxi/crates/luajit/src/pushable.rs~:

#+BEGIN_SRC rust
  /// Trait implemented for types that can be pushed onto the Lua stack.
  pub trait Pushable {
      /// Pushes all its values on the Lua stack, returning the number of values
      /// that it pushed.
      unsafe fn push(self, lstate: *mut State) -> Result<c_int, crate::Error>;
  }

  // Ignore another type's impl block targets to the `Pushable` trait...

  impl Pushable for bool {
      unsafe fn push(self, lstate: *mut State) -> Result<c_int, crate::Error> {
          ffi::lua_pushboolean(lstate, self as _);
          Ok(1)
      }
  }
#+END_SRC


=Very important!!!=

=The entry point function name MUST be the same with your plugin name=, as the compiled library has the symbol name: ~_luaopen_YOUR_PLUGIN_ENTRYPOINT_FUNCTION_NAME~!!!

For example:

1. This plugin entrypoint function name: ~my_neovim_configuration~

2. You need to copy/move the library file to your neovim configuration folder with the same name:

#+BEGIN_SRC bash
  mv target/release/libmy_neovim_configuration.dylib ~/.config/nvim/lua/my_neovim_configuration.so

  #
  # You can list the `luaopen` symbol name to confirm.
  #
  nm ~/.config/nvim/lua/my_neovim_configuration.so | rg luaopen
  # 0000000000001080 T _luaopen_my_neovim_configuration
#+END_SRC

3. Load your plugin in Lua: ~require('my_neovim_configuration')~


**** How to do settings

#+BEGIN_SRC rust
  use nvim_oxi as nvim;

  use nvim::api::opts::{OptionOpts, OptionScope};
  use nvim::api::set_option_value;

  ///
  ///
  ///
  pub fn setup() {
      let opts = OptionOpts::builder().scope(OptionScope::Local).build();

      //
      // Call `set_option_value` API to do settigns
      //
      let _ = set_option_value("number", true, &opts);
      let _ = set_option_value("relativenumber", true, &opts);
      let _ = set_option_value("signcolumn", "yes", &opts);

      // ...
  }
#+END_SRC


**** How to set global variable like =vim.g=

#+BEGIN_SRC rust
  use nvim_oxi::api::{set_var};

  //
  // Set leader key to `space`: vim.g.mapleader = ' '
  //
  let _ = set_var("mapleader", " ");
#+END_SRC


**** How to do keybindigs

#+BEGIN_SRC rust
  use crate::utils::{
      kill_other_windows, open_centred_floating_terminal_window, toggle_spell_checking,
  };

  use nvim_oxi::api::{opts::SetKeymapOpts, set_keymap, set_var, types::Mode};


  ///
  ///
  ///
  pub fn setup() {
      //
      // Leader key: <Space>
      //
      let _ = set_keymap(
          Mode::Normal,
          "<Space>",
          "<NOP>",
          &SetKeymapOpts::builder().silent(true).build(),
      );

      let _ = set_var("mapleader", " ");

      //
      // Simple case that replaces the `lhs` to the `rhs`
      //
      let my_common_keybindings: Vec<(Mode, &str, &str, &str)> = vec![
          // -----------------------------------------------------------------------------------
          // Normal settings
          // -----------------------------------------------------------------------------------
          (Mode::Normal, "Y", "y$", "Copy to end of line"),
          (Mode::Normal, "H", "^", "Move to begining of line"),
          (Mode::Normal, "L", "$", "Move to end of line"),
          (Mode::Normal, "W", ":w<CR>", "Save current buffer"),
          (Mode::Normal, "Q", ":q<CR>", "Quit current buffer"),
          (Mode::Insert, "jj", "<ESC>", "'jj': Escape from insert mode"),
          (
              Mode::Normal,
              "<Tab>",
              ":bn<CR>",
              "'Tab': Switch to next buffer",
          ),
          (
              Mode::Normal,
              "<S-Tab>",
              ":bp<CR>",
              "'Shift + Tab': Switch to prev buffer",
          ),
          (
              Mode::Normal,
              "<Space><Space>",
              "<c-^>",
              "'<leader><leader>': Toggles between buffers",
          ),

      ];

      //
      // Call `set_keymap` API to set keybindings
      //
      for bindings in my_common_keybindings {
          let _ = set_keymap(
              bindings.0, // Mode
              bindings.1, // lhs
              bindings.2, // rhs
              &SetKeymapOpts::builder()
                  .desc(bindings.3) // Description
                  .silent(true)     // No echo to command line
                  .build(),
          );
      }


      //
      // What if you want to run closure via callback? Here is the example:
      //
      let my_keybindings_with_callback: Vec<(Mode, &str, &str, Box<dyn Fn()>)> = vec![
          (
              Mode::Normal,
              "<leader>1",
              "'<leader>1': Kill other windows.",
              Box::new(|| {
                  kill_other_windows();
              }),
          ),
          (
              Mode::Normal,
              "<leader>sc",
              "'<leader>sc': Toggle spell checking.",
              Box::new(|| {
                  toggle_spell_checking();
              }),
          ),
          (
              Mode::Normal,
              "<leader>ft",
              "'<leader>ft': Open a floating terminal.",
              Box::new(|| {
                  open_centred_floating_terminal_window();
              }),
          ),
      ];

      for bindings in my_keybindings_with_callback {
          let _ = set_keymap(
              bindings.0, // Mode
              bindings.1, // lhs
              "",         // rhs set to ""
              &SetKeymapOpts::builder()
                  .desc(bindings.2)     // Description
                  .callback(move |_| {  // callback to call your closure
                      bindings.3();     // Your closure here
                      ()                // callback return value
                  })
                  .silent(true)
                  .build(),
          );
      }
  }
#+END_SRC
